#!/usr/bin/perl

# Copyright (c) 2022 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use DBD::Pg qw(:pg_types);
use DBI qw(:sql_types);
use FDC::db;
use Getopt::Std;
use POSIX qw(getpid);
use ReadConf;
use Term::ReadLine;
use Date::Manip;

our $opt_v; # verbose
our $opt_c; # config file
our $opt_p; # poll on/off

$opt_c = $ENV{'HOME'}."/.config/dbq/dbq.conf";

getopts('pv:');

our $v = $opt_v;

if (!defined($v)) {
	$v = 0;
}
if (! -f $opt_c) {
	die "conf file '${opt_c}' EEXIST";
}

my $dbinfo = {
	dsn => "",
	user => "",
	pass => "",
};

my $dbprep = { };

my $r = ReadConf->new;
my $config = $r->readconf($opt_c)->{_};
if (defined($config)) {
	foreach my $id (keys %{$dbinfo}) {
		if (defined($config->{$id})) {
			$dbinfo->{$id} = $config->{$id};
		}
	}
}

foreach my $id (keys %{$dbinfo}) {
	printf "dbinfo=>{%s} = '%s'\n", $id, $dbinfo->{$id};
}

our $db;

init_db($dbinfo);

if (defined($opt_p)) {
	polldb();
	# notreached
}

our $term = Term::ReadLine->new('dbq', *STDIN, *STDOUT);
$term->ornaments(0);

my $line;
while (1) {
	chomp($line = $term->readline('dbq> '));
	$line =~ s/^\s+//;
	$line =~ s/\s+$//;
	if ($v > 0) {
		printf "read: '%s'\n", $line;
	}
	if ($line =~ /^(exit|quit)$/) {
		last;
	}
	if ($line =~ /^add$/) {
		add();
		next;
	}
	if ($line =~ /^ls$/) {
		ls();
		next;
	}
	if ($line =~ /^on$/) {
		on();
		next;
	}
}

exit(0);

sub add {

	my $q = "INSERT INTO dbq (name, dur, stop) values ";
	$q .=   " (?, ?, ?)";

	my $h = db_prep_alloc('dbq_insert', $q);

	my $name = ask('q name? ');
	my $str  = ask('q dur? ');

	my ($secs,$stop) = durtoss($str);

	printf "add name/dur/stop = '%s'/%d/'%s'\n", $name, $secs, $stop;

	my $i=1;
	my $rv;
	eval {
		$rv = $h->bind_param($i++, $name, SQL_CHAR);
		$rv = $h->bind_param($i++, $secs, SQL_INTEGER);
		$rv = $h->bind_param($i++, $stop);
	};
	if ($@) {
		printf STDERR "add: bind_param Error: '%s'\n", $@;
	}

	eval {
		$rv = $h->execute();
	};
	if ($@) {
		printf STDERR "add: execute Error: '%s'\n", $@;
	}
}

sub polldb {
	my $q = "SELECT * from dbq";
	my $d;
	my $datenow = Date::Manip::Date->new();
	my $datedb  = Date::Manip::Date->new();
	while (1) {
		my $sth = $db->doquery($q);
		if (!defined($sth) || $sth == -1) {
			return;
		}

		$datenow->parse("now");
		while ($d = $sth->fetchrow_hashref) {
			if ($d->{triggered} > 0) {
				next;
			}
			$datedb->parse($d->{stop});
			my $cret = $datenow->cmp($datedb);
			printf "%s  %s  %s : %s\n",
				$datenow->printf("%Y-%m-%dT%H:%M:%S"),
				$cret,
				$datedb->printf("%Y-%m-%dT%H:%M:%S"),
				$d->{name};
			if ($cret >= 0) {
				notify($d);
			}
		}
		sleep(5);
	}
	exit(0);
}

sub on {
	ls();

	my $id = ask('Which id? ');
	my $q = "SELECT * from dbq where id = ?";
	my $h = db_prep_alloc('dbq_select_id', $q);

	my $i=1;
	my ($rv,$sth);
	eval {
		$rv = $h->bind_param($i++, $id, SQL_INTEGER);
	};
	if ($@) {
		printf STDERR "on: bind_param Error: '%s'\n", $@;
	}
	eval {
		$rv = $h->execute();
	};
	if ($@) {
		printf STDERR "on: execute Error: '%s'\n", $@;
	}
	if (!defined($h) || $h == -1) {
		return;
	}
	my $d = $h->fetchrow_hashref;
	$h->finish;
	if (!defined($d)) {
		return;
	}

	my ($secs,$stop);

	my $dstr = ask('q dur ['.secstohuman($d->{dur}).']? ');
	$dstr =~ s/^\s+//;
	$dstr =~ s/\s+$//;

	if (length($dstr) > 0) {
		($secs,$stop) = durtoss($dstr);
		my $q = "UPDATE dbq SET triggered = ?, dur = ?, stop = ? ";
		$q .=   "where id = ?";
		$h = db_prep_alloc('update_trigger_dur_stop', $q);
		$i=1;
		eval {
			$rv = $h->bind_param($i++,     0, SQL_INTEGER);
			$rv = $h->bind_param($i++, $secs, SQL_INTEGER);
			$rv = $h->bind_param($i++, $stop);
			$rv = $h->bind_param($i++,   $id, SQL_INTEGER);
		};
		if ($@) {
			printf STDERR "on: bind_param Error: '%s'\n", $@;
		}
	} else {
		($secs,$stop) = durtoss($d->{dur});
		my $q = "UPDATE dbq SET triggered = ?, stop = ? ";
		$q .=   "where id = ?";
		$h = db_prep_alloc('update_trigger_stop', $q);
		$i=1;
		eval {
			$rv = $h->bind_param($i++,   0, SQL_INTEGER);
			$rv = $h->bind_param($i++, $stop);
			$rv = $h->bind_param($i++, $id, SQL_INTEGER);
		};
		if ($@) {
			printf STDERR "on: bind_param Error: '%s'\n", $@;
		}
	}
	eval {
		$rv = $h->execute();
	};
	if ($@) {
		printf STDERR "on: execute Error: '%s'\n", $@;
	}
}

sub ls {
	my $q = "SELECT * from dbq order by id";
	my $sth = $db->doquery($q);
	if (!defined($sth) || $sth == -1) {
		return;
	}
	# header:
	#            '   11. 0 100day 59min 59secs 2022-09-04 14:35:30 testing2'
	my $header = "Timer  Expired?  Duration    Stop Time           Description";
	printf "%s\n", $header;

	my $d;
	while ($d = $sth->fetchrow_hashref) {

		my $dstr = secstohuman( $d->{dur} );

		# '100day 59min 59secs' is 19c

		printf "%5d. %d %19s %s %s\n", $d->{id},
			$d->{triggered},
			$dstr, $d->{stop}, $d->{name};
	}
}

sub ask {
	my ($prompt) = @_;
	my $ret;

	chomp($ret = $term->readline($prompt));
	return $ret;
}
	
sub init_db {
	my ($dbinfo) = @_;

	use DBI::Const::GetInfoType;
	
	$db = FDC::db->new($dbinfo->{dsn}, $dbinfo->{user}, $dbinfo->{pass});

	if (!defined($db)) {
		die "db connection error!";
	}

	my $dbmsname = $db->getdbh()->get_info( $GetInfoType{SQL_DBMS_NAME} );
	my $dbmsver  = $db->getdbh()->get_info( $GetInfoType{SQL_DBMS_VER} );
	my $oidname  = $db->oidname();

	my $dsn = $dbinfo->{dsn};
	if (defined($dsn)) {
		if ($dsn =~ /dbname=([^;]+)/) {
			$dbinfo->{dbname} = $1;
		}
	}
	if (!defined($dbinfo->{dbname})) {
		$dbinfo->{dbname} = "?";
	}

	printf "Connected to dsn '%s' .. dbms name '%s' ver '%s' .. oidname '%s'\n",
		$dbinfo->{dsn}, $dbmsname, $dbmsver, $oidname;

	my @tables;

	my ($serialtype,$blobtype,$tablere,$index_create_re);
	if ($dbmsname eq "PostgreSQL") {
		$serialtype = "serial";
		$blobtype = "bytea";
		$tablere = '\\.%name%$';
		$db->{stats}->{pgsz} = 1;
		$db->{get}->{dbsz} = "SELECT  pg_database_size(datname) db_size FROM pg_database where datname = '";
		$db->{get}->{dbsz} .= $dbinfo->{dbname};
		$db->{get}->{dbsz} .= "' ORDER BY db_size";
		$db->{stats}->{pgct} = $db->do_oneret_query($db->{get}->{dbsz});
		$db->{bbt} = { pg_type => PG_BYTEA };
		$index_create_re = "CREATE %TYPE% INDEX %NAME% ON %TABLE% using btree ( %PARAMS% )";
		$db->do("SET application_name = '?/".getpid()."'");
	} else {
		die "Unhandled dbmsname ${dbmsname}";
	}

	@tables = $db->tables();

	my %tablefound;
	foreach my $tname (@tables) {
		if ($tname =~ /^(information_schema|pg_catalog)\./) {
			next;
		}
		foreach my $tn (('dbq')) {
			my $tre = $tablere;
			$tre =~ s/%name%/$tn/g;
			if ($tname =~ m/$tre/) {
				$tablefound{$tn} = 1;
			}
		}
	}

	if (!defined($tablefound{'dbq'})) {
		my $q = "CREATE TABLE dbq (";
		$q .=   "id ${serialtype}, ";
		$q .=   "name TEXT unique, ";
		$q .=   "dur INT, ";
		$q .=   "stop TIMESTAMP, ";
		$q .=   "triggered INT default 0, ";
		$q .=   "cr  TIMESTAMP default now()";
		$q .=   ")";
		my $sth = $db->doquery($q);
		$sth = init_db_hash($index_create_re, 'dbq_name_idx',
			'dbq', 'name', 'UNIQUE');
		$sth = init_db_hash($index_create_re, 'dbq_id_idx',
			'dbq', 'id');
	}
}

sub db_prep_alloc {
	my ($hname, $prepsql) = @_;

	if (!defined($dbprep->{$hname})) {
		$dbprep->{$hname} = $db->prepare($prepsql);
	}
	return $dbprep->{$hname};
}

sub init_db_hash {
	my ($re, $name, $table, $param, $type) = @_;

	if (!defined($type)) {
		$type = "";
	}
        $re =~ s/%NAME%/$name/;
        $re =~ s/%TABLE%/$table/;
        $re =~ s/%PARAMS%/$param/;
        $re =~ s/%TYPE%/$type/;

	return $db->doquery($re);
}

sub notify {
	my ($d) = @_;

	my $datenow = Date::Manip::Date->new();
	my $delta   = Date::Manip::Delta->new();

	$datenow->parse("now");
	my $deltastr = $d->{dur}."sec";
	$delta->parse($deltastr);
	my $newdate = $datenow->calc($delta, 0);

	# XXX check for shell escapes until perl native notify
	my $cmd = "xmessage";
	$cmd .= " -timeout 5";
	$cmd .= " -center";
	$cmd .= " -print";
	#$cmd .= " -buttons Snooze:0,Dismiss:1,Test:2,A:3,B:4,C:5";
	$cmd .= " -buttons Snooze:0,Dismiss:1,Restart:2";
	$cmd .= " -default Snooze ";
	$cmd .= $d->{name}.", time: $deltastr";
	open(XM,"$cmd|");
	my $line;
	while(<XM>) {
		chomp($line = $_);
		printf "returned '%s' for %s\n", $line, $d->{name};
		if ($line eq "Dismiss") {
			dismiss($d);
			last;
		}
		if ($line eq "Restart") {
			printf "Restart id %d new end %s\n",
				$d->{id},
				$newdate->printf("%Y-%m-%dT%H:%M:%S");
		}
	}
	close(XM);
}

sub dismiss {
	my ($d) = @_;

	my $h = update_trigger_q();
	
	my $i=1;
	my $rv;
	eval {
		$rv = $h->bind_param($i++, 1, SQL_INTEGER);
		$rv = $h->bind_param($i++, $d->{id}, SQL_INTEGER);
	};
	if ($@) {
		printf STDERR "dismiss: bind_param Error: '%s'\n", $@;
	}
	eval {
		$rv = $h->execute();
	};
	if ($@) {
		printf STDERR "dismiss: execute Error: '%s'\n", $@;
	}
}

sub update_trigger_q {
	my $q = "UPDATE dbq SET triggered = ? where id = ?";
	return db_prep_alloc('dbq_update_trigger', $q);
}
	

sub secstohuman {
		my ($duration) = @_;

		my ($day,$hour,$min,$sec) = secstodhms( $duration );

		my $dstr = "";
		if ($day > 0) {
			$dstr .= " ${day}day";
		}
		if ($hour > 0) {
			$dstr .= " ${hour}hour";
		}
		if ($min > 0) {
			$dstr .= " ${min}min";
		}
		if ($sec > 0) {
			$dstr .= " ${sec}secs";
		} elsif ($sec < 1 && length($dstr) < 1) {
			$dstr .= " ${sec}secs";
		}

		$dstr =~ s/^\s+//;
		$dstr =~ s/\s+$//;

		return $dstr;
}

sub secstodhms {
	my ($secs) = @_;

	my ($d, $h,$m,$s);
	$d = POSIX::floor( $secs / (24*60*60) );
	$h = POSIX::floor( ( $secs - $d * (24*60*60) ) / 3600 );
	$m = POSIX::floor( ( $secs - $d * (24*60*60) - $h * (60*60) ) / 60 );
	$s = $secs - $d * (24*60*60) - $h * (60*60) - $m * 60;

	return ($d, $h, $m, $s);
}

# Duration (from now) to Seconds and Stop Time
sub durtoss {
	my ($str) = @_;

	my $date = Date::Manip::Date->new();
	my $delta = Date::Manip::Delta->new();

	$date->parse("now");
	$delta->parse('+'.$str);
	my $newdate = $date->calc($delta, 0); # add = 0, subtract = 1
	my $stop = $newdate->printf("%Y-%m-%dT%H:%M:%S");
	my $dur = $newdate->printf("%s") - $date->printf("%s");

	return ($dur,$stop);
}
